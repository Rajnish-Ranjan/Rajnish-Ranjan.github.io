/*ASSEMBLY LINE SCHEDULING*/
#include<bits/stdc++.h>
using namespace std;
int main(){
int n;
cout<<"no of stages\n";
scanf("%d",&n);
int time[2][n+4];//0 1st line 1 2nd line
int e1,e2,x1,x2;
int shift[2][n+4];
int dp[2][n+4];
int path[n+3];
cout<<"entry time e1 and e2\n";cin>>e1>>e2;cout<<"time for line 1\n";
for(int i=0;i<n;i++)
cin>>time[0][i];cout<<"time for line 2\n";
for(int i=0;i<n;i++)
cin>>time[1][i];cout<<"time for shift line 1to 2\n";
for(int i=0;i<n-1;i++)
cin>>shift[0][i];cout<<"time for shift line 2to 1\n";
for(int i=0;i<n-1;i++)
cin>>shift[1][i];cout<<"exit time x1,x2\n";
cin>>x1>>x2;
dp[0][0]=e1+time[0][0];
dp[1][0]=e2+time[1][0];
// optimal sub problem
for(int i=1;i<n;i++)
{if(dp[0][i-1]<=dp[1][i-1]+shift[1][i-1]){
dp[0][i]= dp[0][i-1]+time[0][i];
}else
{dp[0][i]= dp[1][i-1]+time[0][i]+shift[1][i-1];
}
if(dp[1][i-1]<=dp[0][i-1]+shift[0][i-1]){
dp[1][i]= dp[1][i-1]+time[1][i];
}
else {
dp[1][i]= dp[0][i-1]+time[1][i]+shift[0][i-1];
}
}
dp[0][n-1]+=x1;
dp[1][n-1]+=x2;
// for path
int m=min(dp[0][n-1],dp[1][n-1]);
if(dp[0][n-1]>dp[1][n-1])
path[n-1]=2;
else
path[n-1]=1;
dp[0][n-1]-=x1;
dp[1][n-1]-=x2;
for(int i=n-2;i>=0;i--){
if(path[i+1]==1){
if(dp[0][i]==dp[0][i+1]-time[0][i+1])
path[i]=1;
else
path[i]=2;
}
else if (dp[1][i]==dp[1][i+1]-time[1][i+1])
path[i]=2;	                   
else
path[i]=1;
}
}
cout<<"minimum time ="<<m<<endl;
cout<<"optimal path"<<"::";
for(int i=0;i<n;i++)
cout<<path[i];
cout<<endl;
}

/*MATRIX CHAIN MULTIPLICATION*/
#include<bits/stdc++.h>
using namespace std;
int bracket[10][10];
void parenthesis(int i,int j,int n, char &name)
{	if(i==j)
	{	cout<<name++;
		return;
	}
	cout<<"(";
	parenthesis(i,bracket[i][j],n,name);
	parenthesis(bracket[i][j]+1,j,n,name);
	cout<<")";
}
void matrixchain(int *p,int n)
{	int m[n][n];
	int cost;
	for(int i=1;i<n;i++)
		m[i][i]=0;
	for(int len=2;len<n;len++)
	{	for(int i=1;i<n-len+1;i++)
		{	int j=len+i-1;
			m[i][j]=INT_MAX;
			for(int k=i;k<j;k++)
			{	cost=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];
				if(m[i][j]>cost)
				{	m[i][j]=cost;
					bracket[i][j]=k;
				}
			}
		}
	}
	char name = 'A';
	cout<<"Optimal Parenthesis: ";
	parenthesis(1,n-1,n,name);
	cout<<"\nOptimal cost is "<<m[1][n-1];	
}
int main()
{	int n;
	cin>>n;
	int p[n];
	for(int i=0;i<n;i++)	cin>>p[i];
	matrixchain(p,n);
	return 0;
}

/* TOPOLOGICAL SORTING */
#include<bits/stdc++.h>
using namespace std;
class Graph
{   int n;  // no of vertices
    vector<int> *graph;
    void topologicalsort(int i,bool *visited,stack <int> &s)
    {   visited[i]=true;
        for(int j=0;j<graph[i].size();j++)
        {   if(visited[graph[i][j]]==false)
                topologicalsort(graph[i][j],visited,s);
        }
        s.push(i);
    }
    public:
    Graph(int p)
    {   n=p;
        graph=new vector<int>[p+1];
    }
    void add_edge(int s,int d)
    {   graph[s].push_back(d);        
    }
    void topologicalDriver()
    {   stack <int> s;
    bool *visited=new bool[n+1];
    for(int i=0;i<=n;i++)
       visited[i]=false;
    for(int i=1;i<=n;i++)
    {   if(!visited[i])
            topologicalsort(i,visited,s);
    }
    while(!s.empty())
    {   cout<<s.top()<<" ";
        s.pop();
    }
    }
};
int main()
{	int v,e,x,y;
    cin>>v>>e;
    Graph g(v);
    for(int i=0;i<e;i++)
    {   cin>>x>>y;
        g.add_edge(x,y);
    }
    g.topologicalDriver();
    return 0;
}

/*SCC*/
#include<bits/stdc++.h>
using namespace std;
class Graph
{
    int V;    
    list<int> *adj;    
    void fillOrder(int v, bool visited[], stack<int> &Stack);
    void DFSUtil(int v, bool visited[]);
public:
    Graph(int V)
	{
    this->V = V;
    adj = new list<int>[V];
	}
    void addEdge(int v, int w)
    {
    	adj[v].push_back(w); 
	}
    void printSCCs();
    Graph getTranspose();
};
void Graph::DFSUtil(int v, bool visited[])
{
    visited[v] = true;
    cout << v << " ";
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        list<int>::iterator i;
        for(i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
void Graph::fillOrder(int v, bool visited[], stack<int> &Stack)
{	visited[v] = true;
	list<int>::iterator i;
    for(i = adj[v].begin(); i != adj[v].end(); ++i)
        if(!visited[*i])
            fillOrder(*i, visited, Stack);
    Stack.push(v);
}
void Graph::printSCCs()
{
    stack<int> Stack;
    bool *visited = new bool[V];
    for(int i = 0; i < V; i++)
        visited[i] = false;
    for(int i = 0; i < V; i++)
        if(visited[i] == false)
            fillOrder(i, visited, Stack);
    Graph gr = getTranspose();
    for(int i = 0; i < V; i++)
        visited[i] = false;
    while (Stack.empty() == false)
    {
        int v = Stack.top();
        Stack.pop();
        if (visited[v] == false)
        {
            gr.DFSUtil(v, visited);
            cout << endl;
        }
    }
}
int main()
{
    int v,e,x,y;
    cin>>v>>e;
    Graph g(v);
    for(int i=0;i<e;i++)
    {   cin>>x>>y;
        g.addEdge(x,y);
    }
    g.printSCCs();

    return 0;
}

/*FINDING PATHS*/
#include<bits/stdc++.h>
using namespace std;
class Graph
{
    int V;    
    list<int> *adj;    
    void printAllPathsUtil(int u, int d, bool visited[],
                              int path[], int &path_index)
{
    visited[u] = true;
    path[path_index] = u;
    path_index++;
    if (u == d)
    {
        for (int i = 0; i<path_index; i++)
            cout << path[i] << " ";
        cout << endl;
    }
    else 
    {
        list<int>::iterator i;
        for (i = adj[u].begin(); i != adj[u].end(); ++i)
            if (!visited[*i])
                printAllPathsUtil(*i, d, visited, path, path_index);
    }
   path_index--;
    visited[u] = false;
}
public:
    Graph(int V)
	{
    this->V = V;
    adj = new list<int>[V];
	}
    void addEdge(int v, int w)
    {
    	adj[v].push_back(w); 
	}
    void printAllPaths(int s, int d)
{
    bool *visited = new bool[V];
    int *path = new int[V];
    int path_index = 0;
    for (int i = 0; i < V; i++)
        visited[i] = false;
    printAllPathsUtil(s, d, visited, path, path_index);
}
};
int main()
{
    int v,e,x,y;
    cin>>v>>e;
    Graph g(v);
    for(int i=0;i<e;i++)
    {   cin>>x>>y;
        g.addEdge(x,y);
    }
    int s,d;
    cin>>s>>d;	
    g.printAllPaths(s,d);
    return 0;
}

/*FLOYD WARSHALL*/
#include<iostream>
using namespace std;
#define V 5
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall (int graph[][V])
{
    int dist[V][V], i, j, k;
    for (i = 0; i < V; i++)
        for (j = 0; j < V; j++)
            dist[i][j] = graph[i][j];
    for (k = 0; k < V; k++)
    {
        for (i = 0; i < V; i++)
        {
            for (j = 0; j < V; j++)
            {

                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
    printSolution(dist);
}
void printSolution(int dist[][V])
{
    printf ("Following matrix shows the shortest distances"
            " between every pair of vertices \n");
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
        {
            if (dist[i][j] == INF)
                printf("%7s", "INF");
            else
                printf ("%7d", dist[i][j]);
        }
        printf("\n");
    }
}
 
int main()
{
    
    int graph[V][V] = { {0,   3,  8, INF, -4},
                        {INF, 0,   3, 1, 7},
                        {INF, 4, 0, INF, INF},
                        {2, INF, -5, 0, INF},
                        {INF, INF, INF, 6, 0}
                      };
 
    floydWarshall(graph);
    return 0;
}

/*BELLMANFORD*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
struct Edge
{
    int src, dest, weight;
};
 
struct Graph
{
    int V, E;
    struct Edge* edge;
};
 
struct Graph* createGraph(int V, int E)
{
    struct Graph* graph = 
         (struct Graph*) malloc( sizeof(struct Graph) );
    graph->V = V;
    graph->E = E;
 
    graph->edge = 
       (struct Edge*) malloc( graph->E * sizeof( struct Edge ) );
 
    return graph;
}
 
void printArr(int dist[], int n)
{
    printf("\nVertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}
 
void BellmanFord(struct Graph* graph, int src)
{
    int V = graph->V;
    int E = graph->E;
    int dist[V];
 
    for (int i = 0; i < V; i++)
        dist[i]   = INT_MAX;
    dist[src] = 0;
 
    for (int i = 1; i <= V-1; i++)
    {
        for (int j = 0; j < E; j++)
        {
            int u = graph->edge[j].src;
            int v = graph->edge[j].dest;
            int weight = graph->edge[j].weight;
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }
 
    for (int i = 0; i < E; i++)
    {
        int u = graph->edge[i].src;
        int v = graph->edge[i].dest;
        int weight = graph->edge[i].weight;
    }
 
    printArr(dist, V);
 
    return;
}
 
int main()
{
    int V = 5;  
    int E = 10; 
    struct Graph* graph = createGraph(V, E);
 
    graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = 6;
 
    graph->edge[1].src = 0;
    graph->edge[1].dest = 3;
    graph->edge[1].weight = 7;
 
    graph->edge[2].src = 1;
    graph->edge[2].dest = 2;
    graph->edge[2].weight = 5;
 
    graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 8;
 
    graph->edge[4].src = 1;
    graph->edge[4].dest = 4;
    graph->edge[4].weight = -4;
 
    graph->edge[5].src = 2;
    graph->edge[5].dest = 1;
    graph->edge[5].weight = -2;
 
    graph->edge[6].src = 3;
    graph->edge[6].dest = 2;
    graph->edge[6].weight = -3;
 
    graph->edge[7].src = 3;
    graph->edge[7].dest = 4;
    graph->edge[7].weight = 9;
    
    graph->edge[8].src = 4;
    graph->edge[8].dest = 1;
    graph->edge[8].weight = 2;
    
    graph->edge[9].src = 4;
    graph->edge[9].dest = 2;
    graph->edge[9].weight = 7;
 
    BellmanFord(graph, 0);
 
    return 0;
}

/*DIJKSTRA*/
#include <iostream>
#include <limits.h>
using namespace std;
#define V 9
int minDistance(int dist[], bool sptSet[])
{
   int min = INT_MAX, min_index;
  
   for (int v = 0; v < V; v++)
     if (sptSet[v] == false && dist[v] <= min)
         min = dist[v], min_index = v;
  
   return min_index;
}
int printSolution(int dist[], int n)
{
   printf("Vertex   Distance from Source\n");
   for (int i = 0; i < V; i++)
      printf("%d \t\t %d\n", i, dist[i]);
}
void dijkstra(int graph[V][V], int src)
{
     int dist[V];    
  
     bool sptSet[V];
     
     for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;
  
     dist[src] = 0;
     for (int count = 0; count < V-1; count++)
     {

       int u = minDistance(dist, sptSet);
  
       sptSet[u] = true;
  
       for (int v = 0; v < V; v++)
  
         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                                       && dist[u]+graph[u][v] < dist[v])
            dist[v] = dist[u] + graph[u][v];
     }
  
     printSolution(dist, V);
}
  
int main()
{
   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                      {4, 0, 8, 0, 0, 0, 0, 11, 0},
                      {0, 8, 0, 7, 0, 4, 0, 0, 2},
                      {0, 0, 7, 0, 9, 14, 0, 0, 0},
                      {0, 0, 0, 9, 0, 10, 0, 0, 0},
                      {0, 0, 4, 14, 10, 0, 2, 0, 0},
                      {0, 0, 0, 0, 0, 2, 0, 1, 6},
                      {8, 11, 0, 0, 0, 0, 1, 0, 7},
                      {0, 0, 2, 0, 0, 0, 6, 7, 0}
                     };
  
    dijkstra(graph, 0);
  
    return 0;
}

/*TRANSITIVE CLOSURE*/
#include<stdio.h>
#define V 4
 
void printSolution(int reach[][V]);
 
void transitiveClosure(int graph[][V])
{

    int reach[V][V], i, j, k;
 
    for (i = 0; i < V; i++)
        for (j = 0; j < V; j++)
            reach[i][j] = graph[i][j];
   for (k = 0; k < V; k++)
    {
        for (i = 0; i < V; i++)
        {
            for (j = 0; j < V; j++)
            {
                reach[i][j] = reach[i][j] || (reach[i][k] && reach[k][j]);
            }
        }
    }
 
    printSolution(reach);
}
 
void printSolution(int reach[][V])
{
    printf ("Following matrix is transitive closure of the given graph\n");
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
            printf ("%d ", reach[i][j]);
        printf("\n");
    }
}
int main()
{
    int graph[V][V] = { {1, 0, 0, 0},
                        {0, 1, 1, 1},
                        {0, 1, 1, 0},
                        {1, 0, 1, 1}
                      };
 
    transitiveClosure(graph);
    return 0;
}

/*RABIN KARP ALGO*/
#include<stdio.h>
#include<string.h>
#define d 256
int main()
{char txt[80],pat[10];
printf("\n ** Rabinkarp Pattern Matcher **\n\n");
printf("Enter the text string:  ");
gets(txt);

printf("\nEnter the pattern to be searched:  ");
gets(pat);
int q = 101;
int M = strlen(pat);
int N = strlen(txt);
int i, j;
int p = 0;
int t = 0;
int h = 1;
for (i = 0; i < M-1; i++)
h = (h*d)%q;
for (i = 0; i < M; i++)
{
p = (d*p + pat[i])%q;

t = (d*t + txt[i])%q;
}




for (i = 0; i <= N - M; i++)
{
if ( p == t )
{
for (j = 0; j < M; j++)
{

if (txt[i+j] != pat[j])
break;
}
if (j == M)
{
printf("pattern matches at shift=%d \n", i);
}
else{
printf(“spurious hit at shift=%d\n, i ”)
}
}
if ( i < N-M )
{
t = (d*(t - txt[i]*h) + txt[i+M])%q;
if(t < 0)
t = (t + q);
}

}
return 0;}


/*STRING AUTOMATA*/
#include<stdio.h>
#include<conio.h>
#include<string.h>
char t[100];
char p[100];
int m,n,i,j=0,k,x,q,d[100][26],l;

void compute_transition_function()
{
m=strlen(p);
for(q=0;q<=m;q++)
{

for(i=0;i<l;i++)
{
if(m<q+1)
{k=m;x=1;}
else {k=q+1;

x=0;}

while(k!=0){
j=0;
while(p[j]==p[x+j]&&j<k-1)
j++;
if(p[j]==i+97)
j++;
if(j==k)
break;
else {k--;x++;}
}
d[q][i]=k;
}
}
}
void finite_automaton_matcher(){
n=strlen(t);
m=strlen(p);
q=0;
for(i=0;i<n;i++)
{
q=d[q][t[i]-97];

if(q==m)
printf("pattern occur with shift %d\n",i-m+1);
}

}

int main(){
printf("Enter the text: ");

gets(t);
printf("Enter pattern: ");
gets(p);
printf("Enter no. of chars: ");
scanf("%d",&l);
compute_transition_function();
finite_automaton_matcher();
printf("\nTransition Function :\n\n");

for(i=0;i<=m;i++){
for(j=0;j<l;j++){
printf("%d\t",d[i][j]);
}
printf("\n");
}
return 0;
}


/*LUP*/
#include<stdio.h>
float a[4][4]={{2,0,2,0.6},   
	     {3,3,4,-2},
	     {5,5,4,2},
	     {-1,-2,3.4,-1}
		};

int p[4][4]={{1},{2},{3},{4}};
float l[4][4];
float u[4][4];

int main()
{

int n=4;  //no. of rows in A
int i,k,j,p2;
float p1;
float temp;



for(k=0;k<n;k++)
{
p1=0;
	for(i=k;i<n;i++)    //choosing pivot
	{
		if(a[i][k]<0)
		{
		temp=-1*a[i][k];
		}
		else
		{
		temp=a[i][k];
		}

		if(temp>p1)
		{
		p1=temp;
		p2=i;
		}
	}

if(p1==0) 
{
printf("\n error");
}

printf("\n pivot is :%f", p1);

temp=p[k][0];
p[k][0]=p[p2][0];
p[p2][0]=temp;

for(i=0;i<n;i++)
{
temp=a[k][i];
a[k][i]=a[p2][i];
a[p2][i]=temp;                                          
}
for(i=k+1;i<n;i++)
{
a[i][k]=a[i][k]/a[k][k];

	for(j=k+1;j<n;j++)
	{
	a[i][j]=a[i][j]-a[i][k]*a[k][j];
	}

}
printf("\n A MATRIX: \n ");

for(i=0;i<4;i++)
{
printf("\n");
	for(j=0;j<4;j++)
	{
	printf(" %0.02f ",a[i][j]);
	}
}
}
printf("\n P MATRIX: \n ");

for(i=0;i<4;i++)
{
printf("\n");
	for(j=0;j<4;j++)
	{
	printf(" %d ",p[i][j]);
	}
}
printf("\n P MATRIX: \n ");

for(i=0;i<4;i++)
{
j=p[i][0];
j--;
for(k=0;k<4;k++)
{
if(k==j)
{
p[i][k]=1;
}
else
{
p[i][k]=0;
}
}
}
printf("\n final Permutation MATRIX: \n ");

for(i=0;i<4;i++)
{
printf("\n");
	for(j=0;j<4;j++)
	{
	printf(" %d ",p[i][j]);
	}
}
for(i=0;i<4;i++)
{

	for(j=0;j<4;j++)
	{
if(i==j)
{
l[i][j]=1;
u[i][j]=a[i][j];
}
else if(i>j)
{
l[i][j]=a[i][j];
u[i][j]=0;
}
else
{
l[i][j]=0;
u[i][j]=a[i][j];
}
	}
}
printf("\n final L MATRIX: \n ");

for(i=0;i<4;i++)
{
printf("\n");
	for(j=0;j<4;j++)
	{
	printf(" %0.02f ",l[i][j]);
	}
}
printf("\n final U MATRIX: \n ");

for(i=0;i<4;i++)
{
printf("\n");
	for(j=0;j<4;j++)
	{
	printf(" %0.02f ",u[i][j]);
	}
}
return 0;
}


/*JOHNSONS'S ALGORITHM*/
#include<stdio.h>
int graph[4][4];
int d[4];
int dist[3];
int parent[3];
int finish[3];
int relax(int u)
{
      int i=0;
    for(i=0;i<=3;i++)
    {
        if(graph[u][i]!=1000)
        {
            if(d[i]>d[u]+graph[u][i])
            {
                d[i]=d[u]+graph[u][i];
            }
        }
    }

    return 0;
}
int relax_to_detect_cycle(int u)
{
      int i=0;
      int cycle=0;
    for(i=0;i<=3;i++)
    {
        if(graph[u][i]!=1000)
        {
            if(d[i]>d[u]+graph[u][i])
            {
                d[i]=d[u]+graph[u][i];
                cycle=1;
                break;

            }
        }
    }

    return cycle;
}

int main()
{
    int i=0,k;
      for(i=0;i<=3;i++)
      {
          d[i]=1000; 
      }


int j;

    for(i=0;i<4;i++)
    {

        for(j=0;j<4;j++)
        {
           graph[i][j]=1000;

    }

    }




      int e;
do{
      printf("\n enter edge cost fron node:i to node:k (enter -1 to stop)\n");
printf(" Source node i:  \n");
scanf("%d",&i);
printf(" Destination node k:  \n");
scanf("%d",&k);
printf(" edge cost:  \n");
scanf("%d",&e);
if(i!=-1||k!=-1)
    graph[i][k]=e;
}while(i!=-1&&k!=-1);




i=3;
for(k=0;k<=2;k++){
    graph[i][k]=0;
}


printf("\n Graph: \n");
    for(i=0;i<4;i++)
    {
        printf("|");
        for(j=0;j<4;j++)
        {
           printf("  %d  ",graph[i][j]);

    }
     printf("|\n");
    }

      d[3]=0;  
      for(i=0;i<=2;i++)  
      {
          for(k=3;k>=0;k--)
          {
              relax(k);
          }

      }
      int cycle;
       for(k=3;k>=0;k--)   
          {
              cycle=relax_to_detect_cycle(k);
              if(cycle==1)
              {
                  break;
              }
          }

       if(cycle==1)
       {

           printf("\n there is negative edge cycle, minimum distance is not possibe \n");
       }
       
       for(i=0;i<3;i++)
       {
           graph[3][i]=d[i];
       }



int w[3];

for(i=0;i<3;i++)
{
    for(j=0;j<3;j++)
    {
        if(graph[i][j]!=1000)
        {
            graph[i][j]=graph[i][j]+d[i]-d[j];
        }
    }

}


printf("\n Modified Graph: \n");
    for(i=0;i<4;i++)
    {
        printf("|");
        for(j=0;j<4;j++)
        {
           printf("  %d  ",graph[i][j]);

    }
     printf("|\n");
    }

int nd=0;
while(nd<3)
{

    for(i=0;i<3;i++)
    {
    parent[i]=nd;
    dist[i]=1000;
    }
       for(i=0;i<3;i++)
    {
        finish[i]=0; 
    }

    dist[nd]=0; 
    parent[nd]=-1;
    int u=nd;
   
int round; 
     int min_node=-1;
     min_node=u;  
    k=0;
    while(k<3)
    {
round=k+1;
       for(i=0;i<3;i++)
    {
      if(graph[min_node][i]!=1000)    
      {
   
          relax_djkstra(min_node,i);

      }
    }

    finish[min_node]=1;  
int temp=0;
    for(i=0;i<3;i++)
    {
        if(dist[i]!=1000 && finish[i]!=1)
        {
          if(temp==0)
          {
              min_node=i;
              temp=1;
          }
            if(dist[min_node]>dist[i])
            {
                min_node=i;

            }
        }
    }
    k++;
    }

    printf("\n The final distance matrix from source node:%d ---- \n",u);
    for(i=0;i<4;i++)
    {
        printf("%d ",dist[i]);
    }
        printf("\n The parent matrix from source node:%d ---- \n",u);
    for(i=0;i<4;i++)
    {
        printf("%d ",parent[i]);
    }



nd++;
}
    return 0;
}
    int relax_djkstra(u,v)
    {
        if(dist[v]>dist[u]+graph[u][v])
        {
            dist[v]=dist[u]+graph[u][v];
            parent[v]=u;
        }


    }

/*MULTIPLE LINE SEGMENT*/
#include<stdio.h>
#include<malloc.h>

struct point{
        char flag;
        int x;
        int y;
};

struct line{
        struct point *p1;
        struct point *p2;
};

int Direction(struct point *p1,struct point *p2,struct point *p3)
{        
        return ((p1->x-p3->x)*(p2->y-p3->y) - (p2->x-p3->x)*(p1->y-p3->y));
}

int Onsegment(struct point *p1,struct point *p2,struct point *p3)
{
        int minx, maxx, miny, maxy;
        if(p1->x >= p2->x){
                minx=p2->x;
                maxx=p1->x;
        }
        else{
                minx=p1->x;
                maxx=p2->x;
        }
        if(p1->y >= p2->y){
                miny=p2->y;
                maxy=p1->y;
        }
        else{
                miny=p1->y;
                maxy=p2->y;
        }

        if((minx<=p3->x) && (p3->x<=maxx) && (miny<=p3->y) && (p3->y<=maxy))
                return 1;
        else
                return 0;
}

int Intersect(struct point *p1,struct point *p2,struct point *p3,struct point *p4)
{        
        int d1,d2,d3,d4;        
        d1 = Direction(p3,p4,p1);
        d2 = Direction(p3,p4,p2);
        d3 = Direction(p1,p2,p3);
        d4 = Direction(p1,p2,p4);
        if(((d1>0&&d2<0) || (d1<0&&d2>0)) && ((d3>0&&d4<0) || (d3<0&&d4>0))){
                return 1;
        }
        else if((d1==0 && Onsegment(p3,p4,p1)==1) || (d2==0 && Onsegment(p3,p4,p2)==1) || (d3==0 && Onsegment   (p1,p2,p3)==1) || (d4==0 && Onsegment(p1,p2,p4)==1)){
                return 1;                
        }
        else{
                return 0;
        }
}

void main()
{
        struct point *p1,*p2,*p3,*p4,*p5,*p6;
        struct line *li[3];
        int r,i,j;
        p1 = (struct point*)malloc(sizeof(struct point));
        p2 = (struct point*)malloc(sizeof(struct point));
        p3 = (struct point*)malloc(sizeof(struct point));
        p4 = (struct point*)malloc(sizeof(struct point));
        p5 = (struct point*)malloc(sizeof(struct point));
        p6 = (struct point*)malloc(sizeof(struct point));
        printf("\nEnter first point.\n");
        scanf("(%d,%d)",&p1->x,&p1->y);
        printf("\nEnter second point.");
        scanf(" (%d,%d)",&p2->x,&p2->y);
        printf("\nEnter third point.");
        scanf(" (%d,%d)",&p3->x,&p3->y);
        printf("\nEnter fourth point.");
        scanf(" (%d,%d)",&p4->x,&p4->y);
        printf("\nEnter fifth point.");
        scanf(" (%d,%d)",&p5->x,&p5->y);
        printf("\nEnter sixth point.");
        scanf(" (%d,%d)",&p6->x,&p6->y);
        li[0] = (struct line*)malloc(sizeof(struct line));
        li[1] = (struct line*)malloc(sizeof(struct line));
        li[2] = (struct line*)malloc(sizeof(struct line));
        li[0]->p1 = p1;
        li[0]->p2 = p2;
        li[1]->p1 = p3;
        li[1]->p2 = p4;
        li[2]->p1 = p5;
        li[2]->p2 = p6;
        for(i=0;i<3;i++){
                for(j=i+1;j<3;j++){
                        r = Intersect(li[i]->p1,li[i]->p2,li[j]->p1,li[j]->p2);
                        if(r==1)
                                printf("(%d,%d) Both line intersects.\n",i,j);
                        else
                                printf("(%d,%d) line doesn't intersect.\n",i,j);
                }        
        } 
}

/*MODULAR EXPONENTIATION*/
#include <iostream>
#define ll long long
using namespace std; 
ll modular_pow(ll base, ll exponent, int modulus)
{
    ll result = 1;
    while (exponent > 0)
    {
        if (exponent % 2 == 1)
            result = (result * base) % modulus;
        exponent = exponent >> 1;
        base = (base * base) % modulus;
    }
    return result;
}

int main()
{
    ll x, y;
    int mod;
    cout<<"Enter Base Value: ";
    cin>>x;
    cout<<"Enter Exponent: ";
    cin>>y;
    cout<<"Enter Modular Value: ";
    cin>>mod;
    cout<<endl<<modular_pow(x, y , mod);
    return 0;
}


/*KMP MATCHING*/
#include<bits/stdc++.h>
using namespace std;
int main(){
string T,P;
cout<< "\nEnter The Text\n";
cin>>T;
cout<< "\nEnter The Pattern\n";
cin>>P;
int n=T.size(),m=P.size();
int pi[m];
pi[0]=0;
int k=0,i;
cout<<" pi :"<<pi[0];
for(i=1;i<m;i++){
	while(k>0&&P[k]!=P[i])
		k=pi[k-1];
	if(P[k]==P[i])
		k++; pi[i]=k;
	cout<<pi[i];
}
cout<< endl;
int q=0;
for(i=0;i<n;i++){
	while(q>0&&P[q]!=T[i])
		q=pi[q-1];
	if(P[q]==T[i])
		q++;
	if(q==m){
		cout<<"\nPattern at shift : "<<i-m+1;
		q=pi[q-1];
	}
}
return 0;}

/*FAST FOURIER TRANSFORM*/
#include<bits/stdc++.h>
using namespace std;
typedef complex<double> Complex;
const double PI = 3.141592653589793238460;
 
int reverseBits(int num)
{
    unsigned int count = sizeof(num) * 8 - 1;
    unsigned int reverse_num = num;
   
    num >>= 1;
    while(num)
    {
       reverse_num <<= 1;    
       reverse_num |= num & 1;
       num >>= 1;
       count--;
    }
    reverse_num <<= count;
    return reverse_num;
}
 
valarray<Complex> ifft(valarray<Complex> primal,int absP)
{
    int i,j,k,p,n = primal.size(),offset;
    valarray<Complex> dual(n);
    for(i = 0;i<n;i++)
    {
        dual[i] = primal[reverseBits(i)>>(32-absP)];
    }
    for(p = 1;p<=absP;p++)
    {
        int unityStep = (1<<p);
        double theta = 2*M_PI/unityStep;
        Complex unityRoot(cos(theta),sin(theta));
        for(offset = 0;offset<n;offset += unityStep)
        {
            Complex omega = 1;
            for(k = 0;k<unityStep/2;k++)
            {
                Complex u = dual[offset+k];
                Complex t = omega*dual[offset+k+unityStep/2];
                omega = omega*unityRoot;
                dual[offset+k] = u+t;
                dual[offset+k+unityStep/2] = u-t;
            }
        }
    }
    return dual;
}
 
int main()
{
   
    double n,i,j,k;
    cout<<"Enter no. of coefficients\n";
    cin>>n;
    valarray<Complex> primal(n);
    for(i = 0;i<n;i++)
    {
        primal[i] = 1+rand()%100;
    }
    int p = log2(n);
    if(pow(2,p) != n)
    {
        cout<<"n should be power of 2\n";
        exit(1);
    }
   
    valarray<Complex> y = ifft(primal,p);
    for(i = 0;i<n;i++)
    {
        cout<<y[i]<<"\n";
    }
}

/^BINOMIAL HEAP*/
#include<stdio.h>
#include<malloc.h>
struct node
{
int n;
int degree;
struct node* parent;
struct node* child;
struct node* sibling;
};
struct node* MAKE_bin_HEAP();
int bin_LINK(struct node*,struct node*);
struct node* CREATE_NODE(int);
struct node* bin_HEAP_UNION(struct node*,struct node*);
struct node* bin_HEAP_INSERT(struct node*,struct node*);
struct node* bin_HEAP_MERGE(struct node*,struct node*);
struct node* bin_HEAP_EXTRACT_MIN(struct node*);
int REVERT_LIST(struct node*);
int DISPLAY(struct node*);
struct node* FIND_NODE(struct node*,int);
int bin_HEAP_DECREASE_KEY(struct node*,int,int);
int bin_HEAP_DELETE(struct node*,int);
int count=1;
struct node* MAKE_bin_HEAP()
{
struct node* np;
np=NULL;
return np;
}
struct node * H=NULL;struct node *Hr=NULL;
int bin_LINK(struct node* y,struct node* z)
{
y->parent=z;
y->sibling=z->child;
z->child=y;
z->degree=z->degree+1;
}
struct node* CREATE_NODE(int k)
{
struct node* p;//new node;
p=(struct node*)malloc(sizeof(struct node));
p->n=k;
return p;
}
struct node* bin_HEAP_UNION(struct node* H1,struct node* H2)
{
struct node* prev_x;
struct node* next_x;
struct node* x;
struct node* H=MAKE_bin_HEAP();
H=bin_HEAP_MERGE(H1,H2);
if(H==NULL)
return H;
prev_x=NULL;
x=H;
next_x=x->sibling;
while(next_x!=NULL)
{
if((x->degree!=next_x->degree)||((next_x->sibling!=NULL)&&(next_x->sibling)->degree==x->degree))
{
prev_x=x;
x=next_x;
}
else
{
if(x->n<=next_x->n)
{
x->sibling=next_x->sibling;
bin_LINK(next_x,x);
}
else
{
if(prev_x==NULL)
H=next_x;
else
prev_x->sibling=next_x;
bin_LINK(x,next_x);
x=next_x;
}
}
next_x=x->sibling;
}
return H;
}
struct node* bin_HEAP_INSERT(struct node* H,struct node* x)
{
struct node* H1=MAKE_bin_HEAP();
x->parent=NULL;
x->child=NULL;
x->sibling=NULL;
x->degree=0;
H1=x;
H=bin_HEAP_UNION(H,H1);
return H;
}
struct node* bin_HEAP_MERGE(struct node* H1,struct node* H2)
{
struct node* H=MAKE_bin_HEAP();
struct node* y;
struct node* z;
struct node* a;
struct node* b;
y=H1;
z=H2;
if(y!=NULL)
{
if(z!=NULL&&y->degree<=z->degree)
H=y;
else if(z!=NULL&&y->degree>z->degree)//need some modificationss here;the first and the else conditions can be merged together!!!!
H=z;
else
H=y;
}
else
H=z;
while(y!=NULL&&z!=NULL)
{
if(y->degree<z->degree)
{
y=y->sibling;
}
else if(y->degree==z->degree)
{
a=y->sibling;
y->sibling=z;
y=a;
}
else
{
b=z->sibling;
z->sibling=y;
z=b;
}
}
return H;
}
int DISPLAY(struct node* H)
{
struct node* p;
if(H==NULL)
{
printf("\nHEAP EMPTY");
return 0;
}
printf("\nTHE ROOT NODES ARE:-\n");
p=H;
while(p!=NULL)
{
printf("%d",p->n);
if(p->sibling!=NULL)
printf("-->");p=p->sibling;
}
printf("\n");
}
struct node* bin_HEAP_EXTRACT_MIN(struct node* H1)
{
int min;
struct node* t=NULL;
struct node* x=H1;
struct node *Hr;
struct node* p;
Hr=NULL;
if(x==NULL)
{
printf("\nNOTHING TO EXTRACT");
return x;
}
// int min=x->n;
p=x;
while(p->sibling!=NULL)
{
if((p->sibling)->n<min)
{
min=(p->sibling)->n;
t=p;
x=p->sibling;
}
p=p->sibling;
}
if(t==NULL&&x->sibling==NULL)
H1=NULL;
else if(t==NULL)
H1=x->sibling;
else if(t->sibling==NULL)
t=NULL;
else
t->sibling=x->sibling;
if(x->child!=NULL)
{
REVERT_LIST(x->child);
(x->child)->sibling=NULL;
}
H=bin_HEAP_UNION(H1,Hr);
return x;
}
int REVERT_LIST(struct node* y)
{
if(y->sibling!=NULL)
{
REVERT_LIST(y->sibling);
(y->sibling)->sibling=y;
}
else
{
Hr=y;
}
}
struct node* FIND_NODE(struct node* H,int k)
{
struct node* x=H;
struct node* p=NULL;
if(x->n==k)
{
p=x;
return p;
}
if(x->child!=NULL&&p==NULL)
{
p=FIND_NODE(x->child,k);
}
if(x->sibling!=NULL&&p==NULL)
{
p=FIND_NODE(x->sibling,k);
}
return p;
}
int bin_HEAP_DECREASE_KEY(struct node* H,int i,int k)
{
int temp;
struct node* p;
struct node* y;
struct node* z;
p=FIND_NODE(H,i);
if(p==NULL)
{
printf("\nINVALID CHOICE OF KEY TO BE REDUCED");
return 0;
}
if(k>p->n)
{
printf("\nSORY!THE NEW KEY IS GREATER THAN CURRENT ONE");
return 0;
}
p->n=k;
y=p;
z=p->parent;
while(z!=NULL&&y->n<z->n)
{
temp=y->n;
y->n=z->n;
z->n=temp;
y=z;
z=z->parent;
}
printf("\nKEY REDUCED SUCCESSFULLY!");
}
int bin_HEAP_DELETE(struct node* H,int k)
{
struct node* np;
if(H==NULL)
{
printf("\nHEAP EMPTY");
return 0;
}
bin_HEAP_DECREASE_KEY(H,k,-1000);
np=bin_HEAP_EXTRACT_MIN(H);
if(np!=NULL)
printf("\nNODE DELETED SUCCESSFULLY");
}
int main()
{
int i,n,m,l;
struct node* p;
struct node* np;
//struct node *H;
char ch;
printf("\nENTER THE NUMBER OF ELEMENTS:");
scanf("%d",&n);
printf("\nENTER THE ELEMENTS:\n");
for(i=1;i<=n;i++)
{
scanf("%d",&m);
np=CREATE_NODE(m);
H=bin_HEAP_INSERT(H,np);
}
DISPLAY(H);
do
{
printf("\nMENU:-\n");
printf("\n1)INSERT AN ELEMENT\n2)EXTRACT THE MINIMUM KEY NODE\n3)DECREASE A NODE KEY\n4)DELETE A NODE\n5)QUIT\n");
scanf("%d",&l);
switch(l)
{
case 1:do
{
printf("\nENTER THE ELEMENT TO BE INSERTED:");
scanf("%d",&m);
p=CREATE_NODE(m);
H=bin_HEAP_INSERT(H,p);
printf("\nNOW THE HEAP IS:\n");
DISPLAY(H);
printf("\nINSERT MORE(y/Y)= \n");
fflush(stdin);
scanf("%c",&ch);
}while(ch=='Y'||ch=='y');
break;
case 2:do
{
printf("\nEXTRACTING THE MINIMUM KEY NODE");
p=bin_HEAP_EXTRACT_MIN(H);
if(p!=NULL)
printf("\nTHE EXTRACTED NODE IS %d",p->n);
printf("\nNOW THE HEAP IS:\n");
DISPLAY(H);
printf("\nEXTRACT MORE(y/Y)\n");
fflush(stdin);
scanf("%c",&ch);
}while(ch=='Y'||ch=='y');
break;
case 3:do
{
printf("\nENTER THE KEY OF THE NODE TO BE DECREASED:");
scanf("%d",&m);
printf("\nENTER THE NEW KEY : ");
scanf("%d",&l);
bin_HEAP_DECREASE_KEY(H,m,l);
printf("\nNOW THE HEAP IS:\n");
DISPLAY(H);
printf("\nDECREASE MORE(y/Y)\n");
fflush(stdin);
scanf("%c",&ch);
}while(ch=='Y'||ch=='y');
break;
case 4:do
{
printf("\nENTER THE KEY TO BE DELETED: ");
scanf("%d",&m);
bin_HEAP_DELETE(H,m);
printf("\nDELETE MORE(y/Y)\n");
fflush(stdin);
scanf("%c",&ch);
}while(ch=='y'||ch=='Y');
break;
case 5:printf("\nTHANK U SIR\n");break;
default :printf("\nINVALID ENTRY...TRY AGAIN....\n");
}
}while(l!=5);
}

/*FIBONAACCI HEAP*/
#include <iostream>
#include <cmath>
#include <cstdlib>
using namespace std;

struct node
{
    int n;
    int degree;
    node* parent;
    node* child;
    node* left;
    node* right;
    char mark;
    char C;
};
class FibonacciHeap
{
    private:
        int nH;
        node *H;
    public:
        node* InitializeHeap();
        int Fibonnaci_link(node*, node*, node*);
        node *Create_node(int);
        node *Insert(node *, node *);
        node *Union(node *, node *);
        node *Extract_Min(node *);
        int Consolidate(node *);
        int Display(node *);
        node *Find(node *, int);
        int Decrease_key(node *, int, int);
        int Delete_key(node *,int);
        int Cut(node *, node *, node *);
        int Cascase_cut(node *, node *);
        FibonacciHeap()
        {
            H = InitializeHeap();
        }
};
node* FibonacciHeap::InitializeHeap()
{
    node* np;
    np = NULL;
    return np;
}
node* FibonacciHeap::Create_node(int value)
{
    node* x = new node;
    x->n = value;
    return x;
}
node* FibonacciHeap::Insert(node* H, node* x)
{
    x->degree = 0;
    x->parent = NULL;
    x->child = NULL;
    x->left = x;
    x->right = x;
    x->mark = 'F';
    x->C = 'N';
    if (H != NULL)
    {
        (H->left)->right = x;
        x->right = H;
        x->left = H->left;
        H->left = x;
        if (x->n < H->n)
            H = x;
    }
    else
    {
        H = x;
    }
    nH = nH + 1;
    return H;
}
int FibonacciHeap::Fibonnaci_link(node* H1, node* y, node* z)
{
    (y->left)->right = y->right;
    (y->right)->left = y->left;
    if (z->right == z)
        H1 = z;
    y->left = y;
    y->right = y;
    y->parent = z;
    if (z->child == NULL)
        z->child = y;
    y->right = z->child;
    y->left = (z->child)->left;
    ((z->child)->left)->right = y;
    (z->child)->left = y;
    if (y->n < (z->child)->n)
        z->child = y;
    z->degree++;
}
node* FibonacciHeap::Union(node* H1, node* H2)
{
    node* np;
    node* H = InitializeHeap();
    H = H1;
    (H->left)->right = H2;
    (H2->left)->right = H;
    np = H->left;
    H->left = H2->left;
    H2->left = np;
    return H;
}
int FibonacciHeap::Display(node* H)
{
    node* p = H;
    if (p == NULL)
    {
        cout<<"The Heap is Empty"<<endl;
        return 0;
    }
    cout<<"The root nodes of Heap are: "<<endl;
    do
    {
        cout<<p->n;
        p = p->right;
        if (p != H)
        {
            cout<<"-->";
        }
    }
    while (p != H && p->right != NULL);
    cout<<endl;
}
node* FibonacciHeap::Extract_Min(node* H1)
{
    node* p;
    node* ptr;
    node* z = H1;
    p = z;
    ptr = z;
    if (z == NULL)
        return z;
    node* x;
    node* np;
    x = NULL;
    if (z->child != NULL)
        x = z->child;
    if (x != NULL)
    {
        ptr = x;
        do
        {
            np = x->right;
            (H1->left)->right = x;
            x->right = H1;
            x->left = H1->left;
            H1->left = x;
            if (x->n < H1->n)
                H1 = x;
            x->parent = NULL;
            x = np;
        }
        while (np != ptr);
    }
    (z->left)->right = z->right;
    (z->right)->left = z->left;
    H1 = z->right;
    if (z == z->right && z->child == NULL)
        H = NULL;
    else
    {
        H1 = z->right;
        Consolidate(H1);
    }
    nH = nH - 1;
    return p;
}
int FibonacciHeap::Consolidate(node* H1)
{
    int d, i;
    float f = (log(nH)) / (log(2));
    int D = f;
    node* A[D];
    for (i = 0; i <= D; i++)
        A[i] = NULL;
    node* x = H1;
    node* y;
    node* np;
    node* pt = x;
    do
    {
        pt = pt->right;
        d = x->degree;
        while (A[d] != NULL)
        {
            y = A[d];
            if (x->n > y->n)
            {
                np = x;
                x = y;
                y = np;
            }
            if (y == H1)
                H1 = x;
            Fibonnaci_link(H1, y, x);
            if (x->right == x)
                H1 = x;
                A[d] = NULL;
            d = d + 1;
        }
        A[d] = x;
        x = x->right;
    }
    while (x != H1);
    H = NULL;
    for (int j = 0; j <= D; j++)
    {
        if (A[j] != NULL)
        {
            A[j]->left = A[j];
            A[j]->right =A[j];
            if (H != NULL)
            {
                (H->left)->right = A[j];
                A[j]->right = H;
                A[j]->left = H->left;
                H->left = A[j];
                if (A[j]->n < H->n)
                H = A[j];
            }
            else
            {
                H = A[j];
            }
            if(H == NULL)
                H = A[j];
            else if (A[j]->n < H->n)
                H = A[j];
        }
    }
}
int FibonacciHeap::Decrease_key(node*H1, int x, int k)
{
    node* y;
    if (H1 == NULL)
    {
        cout<<"The Heap is Empty"<<endl;
        return 0;
    }
    node* ptr = Find(H1, x);
    if (ptr == NULL)
    {
        cout<<"Node not found in the Heap"<<endl;
        return 1;
    }
    if (ptr->n < k)
    {
        cout<<"Entered key greater than current key"<<endl;
        return 0;
    }
    ptr->n = k;
    y = ptr->parent;
    if (y != NULL && ptr->n < y->n)
    {
        Cut(H1, ptr, y);
        Cascase_cut(H1, y);
    }
    if (ptr->n < H->n)
        H = ptr;
    return 0;
}
int FibonacciHeap::Cut(node* H1, node* x, node* y)
{
    if (x == x->right)
        y->child = NULL;
    (x->left)->right = x->right;
    (x->right)->left = x->left;
    if (x == y->child)
        y->child = x->right;
    y->degree = y->degree - 1;
    x->right = x;
    x->left = x;
    (H1->left)->right = x;
    x->right = H1;
    x->left = H1->left;
    H1->left = x;
    x->parent = NULL;
    x->mark = 'F';
}
int FibonacciHeap::Cascase_cut(node* H1, node* y)
{
    node* z = y->parent;
    if (z != NULL)
    {
        if (y->mark == 'F')
        {
            y->mark = 'T';
	}
        else
        {
            Cut(H1, y, z);
            Cascase_cut(H1, z);
        }
    }
}
node* FibonacciHeap::Find(node* H, int k)
{
    node* x = H;
    x->C = 'Y';
    node* p = NULL;
    if (x->n == k)
    {
        p = x;
        x->C = 'N';
        return p;
    }
    if (p == NULL)
    {
        if (x->child != NULL )
            p = Find(x->child, k);
        if ((x->right)->C != 'Y' )
            p = Find(x->right, k);
    }
    x->C = 'N';
    return p;
}
int FibonacciHeap::Delete_key(node* H1, int k)
{
    node* np = NULL;
    int t;
    t = Decrease_key(H1, k, -5000);
    if (!t)
        np = Extract_Min(H);
    if (np != NULL)
        cout<<"Key Deleted"<<endl;
    else
        cout<<"Key not Deleted"<<endl;
    return 0;
}
int main()
{
    int n, m, l;
    FibonacciHeap fh;
    node* p;
    node* H;
    H = fh.InitializeHeap();
    while (1)
    {
        cout<<"----------------------------"<<endl;
        cout<<"Operations on Binomial heap"<<endl;
        cout<<"----------------------------"<<endl;
        cout<<"1)Insert Element in the heap"<<endl;
        cout<<"2)Extract Minimum key node"<<endl;
        cout<<"3)Decrease key of a node"<<endl;
        cout<<"4)Delete a node"<<endl;
        cout<<"5)Display Heap"<<endl;
        cout<<"6)Exit"<<endl;
        cout<<"Enter Your Choice: ";
        cin>>l;
        switch(l)
        {
        case 1:
            cout<<"Enter the element to be inserted: ";
            cin>>m;
            p = fh.Create_node(m);
            H = fh.Insert(H, p);
            break;
        case 2:
            p = fh.Extract_Min(H);
            if (p != NULL)
                cout<<"The node with minimum key: "<<p->n<<endl;
            else
                cout<<"Heap is empty"<<endl;
            break;
        case 3:
            cout<<"Enter the key to be decreased: ";
            cin>>m;
            cout<<"Enter new key value: ";
            cin>>l;
            fh.Decrease_key(H, m, l);
            break;
        case 4:
            cout<<"Enter the key to be deleted: ";
            cin>>m;
            fh.Delete_key(H, m);
            break;
        case 5:
            cout<<"The Heap is: "<<endl;
            fh.Display(H);
            break;
        case 6:
            exit(1);
        default:
            cout<<"Wrong Choice"<<endl;
        }
    }
    return 0;
}



	
